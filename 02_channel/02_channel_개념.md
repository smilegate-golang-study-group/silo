# 02_channel
> Repositories to run study groups effectively

![Codacy coverage](https://img.shields.io/codacy/coverage/test?label=npm&logo=steam&logoColor=black&style=flat-square)

![](../header.png)

## 채널

내용:

```sh
Go 언어에서 채널이란 고루틴끼리 데이터를 주고받는 통로(파이프)의 역할을 수행합니다. 
make(chan 자료형)을 통해 함수를 생성해야 하며, 채널 연산자 <-를 사용한다는 특징을 가지고 있습니다. 
채널은 어떠한 데이터 타입도 주고 받을 수 있고 실행의 흐름을 동기화 할 수 있습니다.

Go 언어 채널에는 Unbuffered Channel과 Buffered Channel 2가지 채널이 존재합니다. 
Unbuffered Channel은 위에서 살펴본 것과 같이 하나의 하나의 수신자가 송신자로 부터 데이터를 받을 때까지 블록킹하지만, 
Buffered Channel은 수신자가 데이터를 받을 준비가 되어 있더라도 송신자의 지정된 버퍼만큼 데이터를 보내고 다른일을 수행할 수 있도록 합니다.

채널은 고루틴끼리 통신하기 위한 양방향 통로(파이프)이지만 채널을 함수의 인자로 사용할 때는 채널이 수신용인지 송신용인지를 정해서 타입의 안전성을 향상시킬 수 있습니다. 
```

## 동기화
```sh
OS를 기본적으로 공부했다면 동기화가 얼마나 중요한 개념인지 다들 알고 계실 것입니다. 
다중 처리기, 다중 코어에서 어떠한 작업을 분할에서 작업할 시, 해당 작업이 이전 작업 혹은 다른 작업의 같은 메모리 영역을 건들일 경우 예기치 않은 동작이나 치명적인 에러를 나타낼 수 있습니다.
OS 내부적으로 원자적 연산을 보장하기 위해 다양한 기법을 사용하지만, 응용 프로그래머 입장에서도 멀티코어를 잘 처리하기 위해서는 코드안에서의 동기화 처리가 매우 중요합니다. 
다행인 점이라면 Go 언어에서는 동기화 처리를 위한 문법이 상당히 간결하면서도 강력하며, 쉽게 멀티 코어를 지원하는 프로그래밍을 작성할 수 있다는 점입니다. Go 언어에서는 Mutex를 사용합니다.
```

## 셀렉트
```sh
채널을 통해 다중 연산을 하는 경우 이를 손쉽게 사용할 수 있는 셀렉트라는 분기문을 제공합니다. 
이를 통해 원하는 채널에 값이 들어왔을 때만 해당 분기문을 실행하기 때문에 다중 채널을 통한 연산시 동기화 연산으로 확장시킬 수 있습니다.
select 분기문도 default 케이스를 지정할 수 있으며 case에 지정된 채널에 값이 들어오지 않았을 때 즉시 실행됩니다. 
단, default에 적절한 처리를 하지 않으면 CPU 코어를 모두 점유하므로 주의해야 합니다.
```

## 참고사이트
```sh
https://judo0179.tistory.com/88
```